import numpy as np
import random
from TripleManager import TripleManager
from DataLoader import DataLoader
import DatasetUtils
import time
import sys

managers = ["train_manager", "valid_manager", "test_manager"]


def validate_negatives(dataset_path, sample_size=float('inf'), negative_sample_size=float('inf')):
    """
    Validates the negatives generated by TripleManager by checking if they exist in the dataset.
    :param dataset_path: Path to the sample dataset.
    :param sample_size: Number of positive triples to check.
    :param negative_sample_size: Number of negatives to verify per triple.
    """
    # Load the dataset
    train_loader = DataLoader(dataset_path, "train")
    val_loader = DataLoader(dataset_path, "valid")
    test_loader = DataLoader(dataset_path, "test")

    train_manager = TripleManager(train_loader)
    valid_manager = TripleManager(val_loader, train_loader)
    test_manager = TripleManager(test_loader, val_loader, train_loader)

    for manager in [train_manager, valid_manager, test_manager]:
        print(f"\tTesting TripleManager with", len(manager.get_triples()), "triples")
        # manager = TripleManager(train_loader)

        # Convert triples to a set for quick lookup
        positive_triples = set(manager.get_triples())
        print(f"Positive triples: {positive_triples}")

        # Randomly sample some triples to check
        sample_triples = random.sample(manager.get_triples(), min(sample_size, len(manager.get_triples())))

        for h, r, t in sample_triples:
            print(f"Positive triple: ({h}, {r}, {t})")
            corrupted_heads = manager.get_corrupted(h, r, t, 'head')
            corrupted_tails = manager.get_corrupted(h, r, t, 'tail')

            # Pick a random subset of negatives to check
            heads_to_check = random.sample(list(corrupted_heads), min(negative_sample_size, len(corrupted_heads)))
            tails_to_check = random.sample(list(corrupted_tails), min(negative_sample_size, len(corrupted_tails)))

            print(f"New Corrupted Heads: {list(heads_to_check)[:5]}")
            for h_neg in heads_to_check:
                print(f"Checking ({h_neg}, {r}, {t})")
                if (h_neg, r, t) in positive_triples:
                    print(f"ERROR: Corrupted head ({h_neg}, {r}, {t}) is actually a positive triple!")
                    sys.exit()

            print(f"New Corrupted Tails: {list(tails_to_check)[:5]}")
            for t_neg in tails_to_check:
                print(f"Checking ({h}, {r}, {t_neg})")
                if (h, r, t_neg) in positive_triples:
                    print(f"ERROR: Corrupted tail ({h}, {r}, {t_neg}) is actually a positive triple!")
                    sys.exit()

    print("Validation complete.")


def benchmark_corruption_modes(dataset_path, sample_size=1000):
    """
    Benchmarks time taken for different corruption modes.
    :param dataset_path: Path to dataset.
    :param sample_size: Number of triples to process.
    """
    corruption_modes = ['LCWA', 'sensical', 'nonsensical']
    managers = ["train_manager", "valid_manager", "test_manager"]

    # Load the dataset
    train_loader = DataLoader(dataset_path, "train")
    val_loader = DataLoader(dataset_path, "valid")
    test_loader = DataLoader(dataset_path, "test")

    train_manager = TripleManager(train_loader)
    valid_manager = TripleManager(val_loader, train_loader)
    test_manager = TripleManager(test_loader, val_loader, train_loader)

    for mode in corruption_modes:
        print(f"Benchmarking corruption mode: {mode}")
        for i, manager in enumerate([train_manager, valid_manager, test_manager]):
            print(f"\tTesting TripleManager {managers[i]} with", len(manager.get_triples()), "triples")
            # train_loader = DataLoader(dataset_path, "train")
            # manager = TripleManager(train_loader, corruption_mode=mode)

            triples = manager.get_triples()
            start_time = time.time()

            for h, r, t in triples:
                corrupted_heads = manager.get_corrupted(h, r, t, 'head', mode)
                corrupted_tails = manager.get_corrupted(h, r, t, 'tail', mode)

                if len(corrupted_heads) == 0:
                    print(f"\tCorrupted Head Not Found")

                if len(corrupted_tails) == 0:
                    print(f"\tCorrupted Tail Not Found")

            elapsed_time = time.time() - start_time

            hours, minutes, seconds = int(elapsed_time // 3600), int((elapsed_time % 3600) // 60), elapsed_time % 60
            print(f"\tTime Taken: {hours} Hours, {minutes} Minutes, and {seconds:.3f} seconds.\n")


# path = "D:\\Masters\\RIT\\Semesters\\Sem 4\\RA\\Augmented KGE\\Datasets\\Sample Test\\"

def test_triple_manager(dataset):
    dataset_name = DatasetUtils.get_dataset_name(dataset)

    print(f"Testing {dataset}.{dataset_name}")

    folder = "D:\\Masters\\RIT\\Semesters\\Sem 4\\RA\\Augmented KGE\\"

    path = folder + "Datasets/" + dataset_name + "/"

    # validate_negatives(path)
    benchmark_corruption_modes(path)


def main():
    test_datasets = [5]
    for dataset in test_datasets:
        start_time = time.time()

        test_triple_manager(dataset)

        end_time(start_time)


def end_time(start_time):
    # Print the total execution time of the entire code
    total_time = time.time() - start_time
    time_taken = (f"\tTime Taken: "
                  f"{total_time // 3600} Hours, "
                  f"{(total_time % 3600) // 60} Minutes, "
                  f"and {(total_time % 3600) % 60} seconds.")
    print(time_taken)


if __name__ == "__main__":
    main()
